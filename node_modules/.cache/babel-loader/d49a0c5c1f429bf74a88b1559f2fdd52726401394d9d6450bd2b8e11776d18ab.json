{"ast":null,"code":"import React,{useState,useEffect}from'react';import compatibilityData from'../data/compatibility-data.json';// Custom hook to fetch and process compatibility data\nexport const useCompatibilityChecker=()=>{const[data,setData]=useState(null);const[loading,setLoading]=useState(true);const[error,setError]=useState(null);useEffect(()=>{try{// In a real app, this would be a fetch call to an API\n// For this demo, we're using the imported JSON directly\nsetData(compatibilityData);setLoading(false);}catch(err){setError('Failed to load compatibility data');setLoading(false);}},[]);const checkCompatibility=(drugs,diluent)=>{if(!data||!drugs||drugs.length===0||!diluent){return null;}// Sort drugs alphabetically to match the format in our dataset\nconst sortedDrugs=[...drugs].sort();// First check for exact match in our dataset\nconst exactMatch=data.combinations.find(combo=>{if(combo.diluent!==diluent)return false;if(combo.drugs.length!==sortedDrugs.length)return false;// Check if all drugs match (they're already sorted)\nreturn JSON.stringify(combo.drugs.sort())===JSON.stringify(sortedDrugs);});if(exactMatch){return{compatible:exactMatch.compatible,message:exactMatch.compatible?'These drugs are compatible in the selected diluent.':'These drugs are NOT compatible in the selected diluent.',notes:exactMatch.notes};}// If no exact match for 2 or 3 drugs, check if any pair is incompatible\nif(sortedDrugs.length>1){for(let i=0;i<sortedDrugs.length;i++){for(let j=i+1;j<sortedDrugs.length;j++){const pairToCheck=[sortedDrugs[i],sortedDrugs[j]].sort();const pairMatch=data.combinations.find(combo=>{if(combo.diluent!==diluent)return false;if(combo.drugs.length!==2)return false;return JSON.stringify(combo.drugs.sort())===JSON.stringify(pairToCheck);});if(pairMatch&&!pairMatch.compatible){return{compatible:false,message:`${pairToCheck[0]} and ${pairToCheck[1]} are NOT compatible in the selected diluent.`,notes:pairMatch.notes};}}}}// If we have no data on this combination\nreturn{compatible:null,message:'No compatibility data available for this combination.',notes:'Please consult a pharmacist or official drug references.'};};return{data,loading,error,checkCompatibility};};export default useCompatibilityChecker;","map":{"version":3,"names":["React","useState","useEffect","compatibilityData","useCompatibilityChecker","data","setData","loading","setLoading","error","setError","err","checkCompatibility","drugs","diluent","length","sortedDrugs","sort","exactMatch","combinations","find","combo","JSON","stringify","compatible","message","notes","i","j","pairToCheck","pairMatch"],"sources":["/home/ubuntu/drug-compatibility-checker/src/data/useCompatibilityChecker.js"],"sourcesContent":["import React, { useState, useEffect } from 'react';\nimport compatibilityData from '../data/compatibility-data.json';\n\n// Custom hook to fetch and process compatibility data\nexport const useCompatibilityChecker = () => {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    try {\n      // In a real app, this would be a fetch call to an API\n      // For this demo, we're using the imported JSON directly\n      setData(compatibilityData);\n      setLoading(false);\n    } catch (err) {\n      setError('Failed to load compatibility data');\n      setLoading(false);\n    }\n  }, []);\n\n  const checkCompatibility = (drugs, diluent) => {\n    if (!data || !drugs || drugs.length === 0 || !diluent) {\n      return null;\n    }\n\n    // Sort drugs alphabetically to match the format in our dataset\n    const sortedDrugs = [...drugs].sort();\n    \n    // First check for exact match in our dataset\n    const exactMatch = data.combinations.find(combo => {\n      if (combo.diluent !== diluent) return false;\n      if (combo.drugs.length !== sortedDrugs.length) return false;\n      \n      // Check if all drugs match (they're already sorted)\n      return JSON.stringify(combo.drugs.sort()) === JSON.stringify(sortedDrugs);\n    });\n\n    if (exactMatch) {\n      return {\n        compatible: exactMatch.compatible,\n        message: exactMatch.compatible \n          ? 'These drugs are compatible in the selected diluent.' \n          : 'These drugs are NOT compatible in the selected diluent.',\n        notes: exactMatch.notes\n      };\n    }\n\n    // If no exact match for 2 or 3 drugs, check if any pair is incompatible\n    if (sortedDrugs.length > 1) {\n      for (let i = 0; i < sortedDrugs.length; i++) {\n        for (let j = i + 1; j < sortedDrugs.length; j++) {\n          const pairToCheck = [sortedDrugs[i], sortedDrugs[j]].sort();\n          \n          const pairMatch = data.combinations.find(combo => {\n            if (combo.diluent !== diluent) return false;\n            if (combo.drugs.length !== 2) return false;\n            return JSON.stringify(combo.drugs.sort()) === JSON.stringify(pairToCheck);\n          });\n\n          if (pairMatch && !pairMatch.compatible) {\n            return {\n              compatible: false,\n              message: `${pairToCheck[0]} and ${pairToCheck[1]} are NOT compatible in the selected diluent.`,\n              notes: pairMatch.notes\n            };\n          }\n        }\n      }\n    }\n\n    // If we have no data on this combination\n    return {\n      compatible: null,\n      message: 'No compatibility data available for this combination.',\n      notes: 'Please consult a pharmacist or official drug references.'\n    };\n  };\n\n  return { data, loading, error, checkCompatibility };\n};\n\nexport default useCompatibilityChecker;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}